### Numpy ndarray:多维数组对象

在后面提到的内容中，都使用标准的Numpy导入方式 import numpy as np.

Numpy的核心特征之一就是N-维数组对象——ndarray。它是Python中一个快速，灵活的大型数据集容器。数组允许你使用类似于标量的操作语法在整块数据上进行数学计算，例如

```python
import numpy as np
data = np.random.randn(1,10)#生成随机一维数组，有十个元素
data
```

```
array([[ 0.2551586 ,  0.52187281,  0.0085745 ,  2.80145342, -1.11982501,
         0.10432449,  0.39225626,  0.33527026, -0.16326921, -1.53390514]])
```

```python
data*10
data+data
```

这类简单的数学操作可以直接进行并运用到每一个元素当中。

一个ndarray是一个通用的多为同类数据容器，也就是说，它包含的每一个元素均为相同类型。每一个数组都有一个shape属性，用来表征数组每一维度的数量;每一个数组都有一个dtype属性，用来描述数组的数据类型

#### 生成ndarray

生成数组最简单的方式就是使用array函数。array函数接受任意的序列型对象，生成一个新的包含传递数据的Numpy数组。

除了np.array，还有很多其他函数可以创建新数组，例如给定长度及形状后，zeros可以一次性创造全0数组，ones可以一次性创造全1数组。empty创建一个没有初始值的数组。想要创建高维数组，则需要为shape传递一个**元组**

#### ndarray的数据类型

数据类型dtype，是一个特殊的对象，它包含了ndarray需要为某一种类型数据所申明的内存块信息（也称为元数据，即表示数据的数据）

```python
arr1 = np.array([1,2,3],dtype = np.int32)
arr1.dtype
```

```python
dtype('int32')
```

可以使用astype方法显示地转换数组的数据类型，（传入的参数可以是另一个数组的dtype属性，也可以是**类型代码**）***详情可探索Numpy官方文档***

```python
float_arr1 = arr1.astype(np.float64)
float_arr1.dtype
```

```python
dtype('float64')
```

#### Numpy数据算术

数组之所以重要是因为它允许你进行批量操作而无须任何for循环。Numpy用户称这种特性为向量化。任何在两个等尺寸数组之间的算术操作都应用了逐元素操作的方式，**带有标量计算的算术操作，会把计算参数传递给数组的每一个元素**



#### 基础索引与切片

一维数组的索引比较简单，和列表类似

```python
arr = np.arange(10)
arr[5:8] = 12
arr
```

```python
array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])
```

如上所见，如果传入了一个数值给数组的切片，数值被传递给了整个切片。区别于Python的内建列表，数组的切片是原数组的**视图**。这意味着数据并不是被复制了，任何对于视图的修改都会反映到原数组上

举个例子

```python
arr_slice = arr[5:8]
arr_slice
```

```python
array([12, 12, 12])
```

当改变arr_slice，变化也会体现在原数组arr上

```python
arr_slice[1] = 123
arr
```

```python
array([  0,   1,   2,   3,   4,  12, 123,  12,   8,   9])
```

不写切片值的[:]将会引用数组的所有值

PS:如果你还是需要一份数组切片的拷贝而不是一份视图的话，就要显式地复制这个数组，例如arr[5:8].copy()

在多维数组中，可以省略后续索引值，返回的对象将是降低一个维度的数组。因此在一个例如2×2×3的数组arr3d中:

```python
arr3d = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])
arr3d
```

```python
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
```

arr3d[0]是一个2×3的数组

```python
array([[1, 2, 3],
       [4, 5, 6]])
```

**通俗地说，括号里有几个维度就是在原数组基础上降低几个维度，需要注意的是，切片出来的数组都是视图不是拷贝**



#### 数组的切片索引

一维数组和Python列表的一维对象类似，数组可以通过类似的语法进行切片

二维数组就有所不同了，例如:

```python
arr2d = np.array([[1,2,3],[4,5,6],[7,8,9]])
arr2d[:2]
```

```python
array([[1,2,3],[4,5,6]])
```

如上述例子，数组沿着**0轴**进行了切片。表达式arr2d[:2]的含义为选择arr2d的前两“行”

***轴用来为超过一维数组定义的属性，二维数据拥有两个轴：第0轴沿着行的方向垂直向下，第1轴沿着列的方向水平延申。***

***根据官方的说法，1表示横轴，方向从左到右；0表示纵轴，方向从上到下。当axis=1时，数组的变化是横向的，体现出列的增加或者减少。反之，当axis=0时，数组的变化是纵向的，体现出行的增加或减少。***



也可以进行多组切片，与多组索引类似:

```python
arr2d[:2,1:]
```

```python
array([[2, 3],
       [5, 6]])
```



#### 布尔索引

考虑一下例子，假设我们的数据都在数组中，并且数组中的数据是一些存在重复的人名，先用numpy.random中的randn函数来生成一些随机正态分布的数据

```python
name = np.array(['Bob','Joe','Will','Bob','Will','Joe','Joe'])
data = np.random.randn(7,4)
```

假设每个人名都和data数组中的一行对应，并且我们想要选中所有'Bob'对应的行。与数学操作类似，数组的比较操作(比如==)也是可以向量化的。因此，比较names数组和字符串'Bob'会产生一个布尔值数组

```python
names == 'Bob'
```

```python
array([ True, False, False,  True, False, False, False])
```

在索引数组时可以传入布尔值数组:

```python
data[names == 'Bob']
```

```python
array([[ 1.8437316 ,  1.4574289 ,  0.94627392, -1.99155823],
       [-0.62295397,  0.60954632, -0.80780837,  1.34018181]])
```

布尔值数组的长度必须和数组轴索引长度一致。你甚至还可以用切片或整数值对布尔值数组进行混合和搭配

为了选择除了'Bob'以外的其他数据，你可以使用!=或在条件表达式前使用 ~ 对条件取反

```python
names != 'Bob'
data[~(names == 'Bob')]
```

**使用布尔值索引选择数据时，总是生成数据的拷贝，即返回的数组并没有任何变化**



#### 神奇索引

神奇索引是Numpy中的术语，用于描述使用整数数组进行数据索引

假设我们有一个8×4的数组

```python
arr = np.empty((8，4))
for i in range(8):
	arr[i] = i
arr
```

```python
array([[0., 0., 0., 0.],
       [1., 1., 1., 1.],
       [2., 2., 2., 2.],
       [3., 3., 3., 3.],
       [4., 4., 4., 4.],
       [5., 5., 5., 5.],
       [6., 6., 6., 6.],
       [7., 7., 7., 7.]])


```

为了选出一个符合特定顺序的子集，你可以简单地通过传递一个包含知名所需顺序地列表或数组来完成:

```python
arr[[4,3,0,6]]
```

```python
array([[4., 4., 4., 4.],
       [3., 3., 3., 3.],
       [0., 0., 0., 0.],
       [6., 6., 6., 6.]])
```

如果使用负地索引，将从尾部进行选择:

```python
arr[[-3,-5,-7]]
```

```python
array([[5., 5., 5., 5.],
       [3., 3., 3., 3.],
       [1., 1., 1., 1.]])
```

传递多个索引数组时情况有些许不同，这样会根据每个索引元组对应的元素选出一个一维数组:

```python
arr1 = np.arange(32).reshape((8,4))
arr1
```

```python
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])
```

```python
arr1[[1,5,7,2],[0,3,1,2]]
```

```python
array([ 4, 23, 29, 10])
```

在上述例子中，元素(1,0),(5,3),(7,1),(2,2)被选中，如果不考虑数组的维数，神奇索引的结果总是一维的

神奇索引与切片不同，它总是将数据复制到一个新的数组中。



#### 数组转置和换轴

转置是一种特殊的数据重组形式，可以返回底层的数据的视图而不需要复制任何内容。数据拥有transpose方法，也有特殊的T属性:







































官方中文文档:https://www.numpy.org.cn/index.html
